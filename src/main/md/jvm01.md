关闭偏向锁延迟：-XX:BiasedLockingStartupDelay=0
关闭偏向锁：-XX:-UseBiasedLocking=false
cpu实现原子操作：对缓存加锁或是对总线加锁方式
总线锁：处理器提供一下LOCK#信号，当一个处理器在总线上输出此信号时，其它处理器的请求将被组塞住，该处理器可以独占共享内存，把cpu和内存之间的通信锁住，其他处理器也不能操作其它内存地址数据，开销比较大
缓存锁定：内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，允许它的缓存一致性机制来保证操作的原子性，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

不使用缓存锁的场景：当操作数据不能被缓存在处理器内部，或是操作的数据跨多个缓存行时 二：有些处理器不支持缓存锁
Java通过加锁和循环cas实现原子操作

cas问题：1、ABA问题 2、循环时间长开销大3、只能保证一个共享变量的原子操作
查看jvm运行时参数：java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal Benchmark

-XX:+DisableExplicitGC来禁用JVM对显示GC的响应
String的String Pool是一个固定大小的Hashtable 1.7 可通过参数设置-XX:StringTableSize=99991

内存模型：
* 方法区：方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
* JVM堆：线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例
* 程序计数器(Program Counter Register)：线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器
* 本地方法栈(Native Method Stacks)：本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关
* 虚拟机栈(Java Virtual Machine Stacks)：属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息
1. 局部变量表：局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）
2. 操作数栈：操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32 位数据类型所占的栈容量为 1,64 位数据类型所占的栈容量为 2，入栈出栈操作
3. 动态连接：每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接
4. 方法返回地址：当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理

https://mp.weixin.qq.com/s/qPhzhsWJuroOLp46R48JRw

垃圾回收：
* 计算已死对象：引用计数法、可达性分析法(GC-Root:虚拟机栈、方法区中的静态属性引用、方法区中的final属性引用、jni)
* 回收区域：新生代、永久代
* 回收算法：标记-清除、复制算法、标记-整理、分代收集
垃圾收集器：
1. Serial收集器： 新生代收集器、单线程执行、使用复制算法
2. ParNew收集器：Serial收集器的多线程版本
3. Parallel Scavenge收集器：新生代收集器、多线程执行、复制算法、控制参数： 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数、该收集器主要关注吞吐率
4. Serial Old收集器：Serial收集器的老年代版本、单线程、标记-整理算法
5. Parallel Old：Parallel Scavenge收集器的老年代版本、多线程、标记-整理算法
6. CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，重视服务器的响应速度，使用标记-清除算法，分为4个步骤：初始标记、并发标记、重新标记、并发清除。CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的
7. G1收集器：并行与并发，可充分利用多核cpu，分代收集、空间整合、可预测性停顿、
