DNS查询过程命令 dig +trace www.google.com  
拿到IP之后，还需要拿到那台服务器的MAC地址才行，在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址
TCP：
如何保持长链接并识别不同请求：
* tcp通过心跳保持长链接
* 识别不同请求：最初tcp进程在用户进程调用socket的时候，建立了一个映射关系，五元组<——>session ID,[IP Source Address + IP Destination + Source Port + Destination Port + Protocol] <——> sessionId，五元组的作用是从IP进程取来数据使用的，因为IP Header + TCP Header没有这样的session ID，只有五元组做key值；有了这个key值就可以唯一地映射到session ID，于是把tcp   PayLoad提交给session ID 所对应的session

三次握手：
1. 第一次握手：客户端发送建立连接数据包，发送之后状态变成SYN_SENT，数据包内容里面SYN标志位为1以及一个随机的序列号seq，假设值为j。
2. 第二次握手：服务器收到请求之后，发送数据包给客户端，服务器状态变为SYN_RECV,数据包内容包含标志位SYN和ACK，值都为1。确认序列号ack值为j+1，随机序列号seq，假设值为i。
3. 第三次握手：客户端收到服务端的数据包，验证ACK和SYN为1后，发送一个确认数据包，客户端进入ESTABLISHED状态，数据包包括标志位ACK，值为1。确认序列号ack，值为i+1。序列号seq，值为j+1.

tcp断开连接4次挥手：
* 第1次客户端：发送报文 FIN=1, seq=u（等于前面已经发送过来的数据的最后一个字节的序号加1）进入 FIN-WAIT-1（终止等待1） （TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号）
* 第2次服务器：收到连接释放报文发出确认报文，ACK=1, ack=u+1，并且带上自己的序列号 seq=v进入 CLOSE-WAIT（关闭等待） 状态TCP 通知应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接收。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。客户端：接收到服务器的确认请求进入 FIN-WAIT-2（终止等待2） 状态，等待服务器发送连接释放报文（这之前还需要接受服务器发送的最后的数据）。
* 第3次服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，由于在半关闭状态，服务器很可能又发送了一些数据。假定此时的序列号为 seq=w服务器：FIN=1, ACK=1, ack=u+1, seq=w（新的seq）进入 LAST-ACK 状态
* 第4次客户端：客户端接收到服务器的连接释放报文之后，必须发出确认。ACK=1, ack=w+1, seq=u + 1客户端进入 TIME-WAIT（时间等待） 状态经过 2 MSL（Maximum Segment Lifetime）（报文最大生成时间），进入 CLOSED 状态服务器：只要接收到了客户端发出的确认，立即进入 CLOSED 状态服务器比客户端先进入 CLOSED 状态。
tcp标志位：
第一 FLAG - 紧急指针（URGENT POINTER）
第一个标志是紧急指针标志，如上一屏幕截图所示。此标志用于将输入数据标识为“紧急”。这样的进入段不必等待直到先前段被接收端消耗，而是直接发送并立即处理。
在数据传输流中，主机正在向远程机器上运行的应用程序发送数据，可以使用紧急指针。如果出现问题，主机需要中止数据传输，并在另一端停止数据处理。
在正常情况下，中止信号将在远程机器发送和排队，直到所有先前发送的数据都被处理，但是在这种情况下，我们需要立即处理中止信号。
通过将中止信号的段紧急指针标志设置为“1”，远程机器将不会等待所有排队的数据被处理，然后执行中止。相反，它会给出特定的段优先级，立即处理它，并停止进一步的数据处理。

如果您发现很难理解，请考虑这个现实生活中的例子：
在当地的邮局，数以百计的卡车正在卸载来自世界各地的信件。因为进入邮局大楼的卡车数量很多，他们排队一个，等待轮到他们卸下行李。
结果，队列结束了很久。然而，一辆大红标志的卡车突然加入队伍，安全人员的工作是确保没有卡车跳过排队，看到红标志，并且知道它载有非常重要的信件，需要紧急到达目的地。按照正常程序，安全人员向卡车发出信号，跳过队列，一路向前，优先于其他卡车。
在这个例子中，卡车表示到达其目的地并在等待处理的缓冲器中排队的段，而具有红标志的卡车是设置了紧急指针标志的段。
另外要注意的是存在指针指针字段。这个字段在第5节中有所描述，但是我们可以简单地提到，当紧急指针标志设置为'1'（这是我们在这里分析的那个）时，紧急指针字段指定紧急数据结束的段中的位置。

 
第二标记- 确认（ACKNOWLEDGEMENT）
确认标志用于确认数据包的成功接收。
如果在使用TCP传输数据的同时运行数据包嗅探器，您会注意到，在大多数情况下，对于发送或接收的每个数据包，都会进行确认。因此，如果您从远程主机收到数据包，那么您的工作站最有可能将ACK字段设置为“1”。
在发送方每发送一个数据包需要一个确认的情况下，接收端将发送一次预期的ACK（接收到第三个连续的数据包）。这也称为窗口化，并在以下页面中广泛介绍。

第三标志 - PUSH
存在推送标志，如紧急标志，以确保数据被给予优先级（它应得的），并在发送或接收端处理。这个特定的标志在数据传输的开始和结束时被非常频繁地使用，影响数据在两端处理的方式。
当开发人员创建新的应用程序时，他们必须确保它们遵循RFC的特定指导，以确保其应用程序正常工作，并且无缺陷地管理进出OSI模型的应用程序层的数据流。使用时，推送位确保数据段被正确处理，并在虚拟连接的两端给出适当的优先级。
当主机发送其数据时，它将暂时排队在TCP缓冲区中，即存储器中的一个特殊区域，直到该段达到一定大小，然后发送到接收器。这种设计保证数据传输尽可能高效，而不需要通过创建多个片段而不需要花费时间和带宽，而是将它们组合成一个或多个较大的片段。
当段到达接收端时，它被传递到应用层之前被放置在TCP传入缓冲器中。在进入缓冲区中排队的数据将保留在那里，直到其他段到达，并且一旦完成，数据就被传递到等待它的应用层。
虽然这个过程在大多数情况下运行良好，但是有很多情况下这种“排队”的数据是不期望的，因为排队期间的任何延迟都可能导致等待应用程序出现问题。一个简单的例子将是一个TCP流，例如真正的播放器，其中数据必须立即发送和处理（由接收器），以确保平滑的流，没有任何切断。
这里提到的最后一点是，Push标志通常设置在文件的最后一段，以防止缓冲区死锁。当用于通过代理发送HTTP或其他类型的请求时也可以看到，确保请求得到适当和有效的处理。

 
第4标志 - 复位（RST）标志
当段到达不用于当前连接时，使用复位标志。换句话说，如果要向主机发送数据包以建立连接，并且没有这样的服务等待在远程主机上回答，则主机将自动拒绝您的请求，然后向您发送回复RST标志置1。这表示远程主机已重置连接。
虽然这可能是非常简单和合乎逻辑的，但事实是在大多数情况下，这个“特征”被大多数黑客使用，以便扫描“打开”端口的主机。所有现代端口扫描仪都能够通过“复位”功能检测“打开”或“收听”端口。
用于检测这些端口的方法非常简单：当尝试扫描远程主机时，将使用SYN标志位（1）构建有效的TCP段，并将其发送到目标主机。如果没有服务监听特定端口上的入站连接，则远程主机将回复ACK和RST标志设置（1）。另一方面，如果端口上有服务监听，则远程主机将构造一个具有ACK标志位的TCP段（1）。这当然是我们已经涵盖的标准三次握手的一部分。
一旦主机扫描开放端口接收到该段，它将完成三次握手，然后使用FIN（见下文）标志终止它，并将特定端口标记为“活动”。

 
第5标志 - 同步标志（SYNCHRONISATION FLAG）
TCP标志选项中包含的第五个标志可能是TCP通信中使用最知名的标志。您可能会注意到，在建立两台主机之间的经典3次握手时，SYN标志是初始化的：
主机A需要使用TCP作为其传输协议从主机B下载数据。协议需要进行三次握手，以便双方建立虚拟连接才能交换数据。
在三次握手期间，我们可以统计每个主机发送的SYN标志总数为2个。随着文件的交换和新连接的创建，我们将看到更多的SYN标志被发送和接收。

第六标志- FIN 标志
可用的最后一个标志是FIN标志，代表“完成”一词。该标志用于拆除使用上一个标志（SYN）创建的虚拟连接，因此，由于这个原因，当连接之间交换最后一个数据包时，总是出现FIN标志。
重要的是要注意，当主机发送FIN标志来关闭连接时，它可能会继续接收数据，直到远程主机也关闭了连接，尽管这仅在特定情况下发生。一旦连接被双方削减，则释放用于连接的每端的缓冲区。

正常的拆卸过程如下所示：主机A和B之间的现有连接，两个主机正在交换数据。一旦数据传输完成，主机A发送一个包含FIN，ACK标志的数据包（步骤1）。
使用此数据包，主机A确认先前的流，同时启动TCP关闭过程以终止此连接。此时，Host A的应用程序将停止接收任何数据，并将关闭此端的连接。
为了响应主机A关闭连接的请求，主机B将发送确认（STEP 2），并通知其应用程序连接不再可用。一旦完成，主机（B）将发送自己的FIN，ACK标志（步骤3）以关闭其部分连接。
如果您想知道为什么需要执行此过程，则可能需要记住，TCP是一个全双工连接，这意味着有两个方向的数据流。在我们的示例中，这是从主机A到主机B的连接流，反之亦然。另外，它需要两个主机关闭它们的连接，因此两个主机必须发送一个FIN标志并且另一个主机必须确认它的原因。
最后，在步骤4，主机A将确认在步骤3发送的主机B的请求，并且双方的已关闭程序现在已经完成！

TCP和udp的区别：

HTTP：
1. 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接。持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接
2. 一个 TCP 连接可以对应几个 HTTP 请求？
可以发送多个http请求
3. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
    * HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，它的意思是说：两个请求的生命周期不能重叠，任意两个HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。
    * 虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。
    * 由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果。浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。
    * Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题： 
        * 一些代理服务器不能正确的处理 HTTP Pipelining。
        * 正确的流水线实现是复杂的。
        * Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求，按照标准，服务器应该按照收到请求的顺序返回结果。假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。所以现代浏览器默认是  不开启 HTTP Pipelining 的。
    * HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请 求。至于 Multiplexing 具体怎么实现的就是另一个问题了。
    * 所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以 可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。
    * 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：
        * 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
        * 和服务器建立多个 TCP 连接。
4. 为什么有的时候刷新页面不需要重新建立 SSL 连接？
在第一个问题的讨论中已经有了答案：TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的
5. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？
肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受
但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了
要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。
           所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。
Https：
1. 首先是 TCP 三次握手，然后客户端（浏览器）发起一个 HTTPS 连接建立请求，客户端先发一个 Client Hello 的包，然后服务端响应一个 Server Hello。
2. 接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加行加解密数据。
* 在 Client Hello 里面客户端会告知服务端自己当前的一些信息：包括客户端要使用的 TLS 版本，支持的加密套装，要访问的域名，给服务端生成的一个随机数（Nonce）等
* 需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来，因为此时还没有发生 HTTP 请求。
1. 服务端在 Server Hello 里面会做一些响应：
2. 服务端选中的加密套装叫 TLSECDHERSAWITHAES128GCM_SHA256，这一串的意思是：
    * 密钥交换使用 ECDHE
    * 证书签名算法 RSA
    * 数据加密使用 AES 128 GCM
    * 签名校验使用 SHA256
证书包含三部分内容：
* tbsCertificate（to be signed certificate）待签名证书内容
* 证书签名算法
* CA 给的签名
HTTPS 能够验证身份的原理：
* 根证书内置于操作系统
* 假如 Hacker 通过 DNS 欺骗之类的方式把你访问的域名指向了他的机器，然后他再伪造一个证书。
* 但是由于根证书都是内置于操作系统的，所以它改不了签名的公钥，并且它没有正确的私钥，只能用自己的私钥，由于公私钥不配对，很难保证加解密后的信息一致。
* 或者直接把浏览器拿到的证书搬到他自己的服务器？这样再给浏览器发的证书便是一模一样，但是由于他不知道证书的私钥，所以无法进行后续的操作，因此这样是没有意义的。
密钥交换的方式有两种：RSA 和 ECDHE
* RSA 的方式比较简单，浏览器生成一把密钥，然后使用证书 RSA 的公钥进行加密发给服务端，服务再使用它的密钥进行解密得到密钥，这样就能够共享密钥了。它的缺点是攻击者虽然在发送的过程中无法破解，但是如果它保存了所有加密的数据，等到证书到期没有被维护之类的原因导致私钥泄露，那么它就可以使用这把私钥去解密之前传送过的所有数据。
* ECDHE (Elliptic Curve Diffie–Hellman key Exchange 椭圆曲线迪非-赫尔曼密钥交换)是一种更安全的密钥交换算法


https://mp.weixin.qq.com/s/WN8EkGw7J0XIcdCOKm8zyg